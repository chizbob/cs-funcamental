Exercise 
1. What is the main difference between a stack and a queue?
The key difference between the two is whether it is FIFO (first in, first out) or LIFO (last in, last out). FIFO is like first come, first served, like you waiting in line in a shop, whereas LIFO is like last come, first served. Stack is LIFO and Queue is FIFO. 

var stack = [];
stack.push(2);       // stack is now [2]
stack.push(5);       // stack is now [2, 5]
var i = stack.pop(); // stack is now [2]
alert(i);            // displays 5

var queue = [];
queue.push(2);         // queue is now [2]
queue.push(5);         // queue is now [2, 5]
var i = queue.shift(); // queue is now [5]
alert(i);   

2. What are the similarities between stacks and queues? 
They both allow for access to any of the elements in them at a certain order. Also, it's not possible to pick up any element in the middle of stacks/queues. 

3. Imagine you are an engineer tasked with implementing the UNDO and REDO options in a word processor such as Microsoft Word. Which data structure would you use for each option and why?
Undo: LIFO, hence stack (The undo action is taken first upon the latest activity that happened)
Redo: FIFO, hence queue (The redo action is taken first upon ?? 

Programming Questions
1. Given a string, reverse it using a stack. For example, the string "Bloc!" should be converted to "!colB".
Pseudo code)
function to reverse string
  return string.reverse()

Actual code)
function reverseString(string){
  return string.split('').reverse().join('')
}

2. Implement the pop method of a stack using one queue. Make a FIFO data structure mirror the functionality of a LIFO data structure. Since the internal list is not the same as defined in the checkpoint, it may help to rewrite the pseudocode first.
Pseudo code)
Function to dequeue
  variable temp equal to last element
  remove last element from the queue
  return temp

Actual code)
class Queue{
  constructor(){
    this.data=[]
  }
  dequeue(el){
    let temp = this.data.pop
    return this.data
  }
  enqueue(el){
    this.data.push(el)
  }
}

3. Implement the enqueue and dequeue methods defined in the checkpoint inside your own Queue class.
class Queue{
  constructor(){
    this.data=[]
  }
  enqueue(el){
    this.data.push(el) //or .concat(el) if the original array should be kept 
  }
  dequeue(){
    this.data.shift()
  }
}

The end