Exercise
1. What are some pros and cons of using linked lists instead of arrays?
The node, which makes up every linked list, is independent in memory, which means it will be assigned to any available space/location to be stored. This is a huge advantage because in array, the elements should be consecutively located, creating a memory burden. 
However, this may make it hard and inefficient to find the node, since its location is not predictable. 

2. Come up with a real world example of a linked list.
My friend likes a game called the "chained note". The purpose of this game is basically to give you a prize. But for that, you need to do some work. The game goes like this:
She hid many notes and a prize in different areas of the house. 
The first note usually starts on the dining table and gives out a clue about what the prize is and the place to find the next note. 
I should to go to the place that was referenced to on the first note. 
When I go there, I see another note and clue.
As I repeat this process I get better ideas on what's waiting for me. 
Continue on until I get to the final destination and claim the gift, which means the end of the tame.
Of course, the repetition depends on how many notes she left.

Programming Questions
1. The linked list push function should take a value, create a node, and add it to the end of a list. Below is pseudocode for a push function for a singly linked list. However, there is something wrong with it. Submit both an explanation of the bug and a functional implementation of the method.

FUNCTION push(element)
CREATE node
SET node.value TO element
SET node.next TO null

IF the head node does not exist
 THEN SET head to node
ELSE
 SET current to head
 SET current.next to node
END IF
END FUNCTION

The problem of the code above is:
Since this function is supposed to add the value to the end of the list, it should not be set to head. 
And what the variable current means is not clear. Does this refer to the tail node? 

My correction would look like: 
 
function to create push method (element)
  create node                      //create a node with this element
  set node.value to element
  set node.next to null            //since this node is going to be located at the last

  if there is no head (and tail)
    set head to node
    set tail to node
  else 
    set tail.next to node          //to add the value to the end of the list
    set tail to node               //to update the tail 

2. Given an unsorted singly linked list, remove all duplicates from the linked list.
Example
Input: a -> c -> d -> d -> a
Output: a -> c -> d

Pseudo code)
Class node 
  Constructor to assig node
  Function to remove duplicates
     in case of no head - terminate 
  If there's next, head equals to next 
  Else nodes data is true
    Head equals next   

class Node{
  constructor(el){
    this.value = el
    this.next = null
  }
  
  removeDupes(){
    if (!this.head || !this.head.next){
      return
    }
    var p1
    var p2
    var node = {}

    p1 = this.head
    p2 = this.next
    nodes[p1.data] = true

    while(p2){
      var data = p2.data
      if(nodes[data]){
        p1.next = p2.next
      } else {
        nodes[data] = true
        p1 = p2
      }
      p2 = p2.next
    }
  }
}

3. Given an unsorted singly linked list, reverse it.
Example
Input: a -> b -> c -> d
Output: d -> c -> b -> a

Pseudo)
Function to reverse node
  Set current to head
  while there is current node 
    Set next to current's next 
    Set current'next to previous
    Set previous to current 
    Set current to next  

Actual code)
class LinkedList {
  constructor() {
    this.head = null;
    this.length = 0;
  }
  
  reverse(){
    var current = this.head,
    var previous = null
    while(current){
      var next = current.next
      current.next = previous
      previous = current;
      current = next;
    }
    return previous;
  }
}